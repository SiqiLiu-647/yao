<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>yao: algorithms</title>
<script type="text/javascript" src="scripts.js">void=null;</script>
<link rel="stylesheet" href="styles.css" type="text/css">
</head>
<body>


<div id="content">

<h1>yao</h1>

<div id="links">
<p><b>Links</b></p>
<a href="aosimul.html">Main page</a><br>
<a href="installation.html">Installation</a><br>
<a href="examples.html">Examples and Scripts</a><br>
<a href="performance.html">Performance</a><br>
<a href="data-structures.html">Data structures and parfiles</a><br>
<a href="feature-control.html">Controlling Features</a><br>
<a href="screenshots.html">Screenshots</a><br>
<a href="algorithms.html">Algorithms</a><br>
<a href="ytkcontrol.html">Yao tk dynamic control</a><br>
<a href="weblog.html">News/Weblog</a><br>
</div>


<h2>Algorithms</h2>

This page contains the algorithmic for the 2 main yao functions: aoread, aoinit and aoloop. For each of these functions, I list the main tasks and the calls to subroutines/functions. For some of these calls, the actual subroutine is also described (underline links). Click on the function name to expand the content.

<p><a href="#" class="none" onclick="expandAll();" title="click to expand all">Expand all</a> / <a href="#" class="none" onclick="collapseAll();" title="click to collapse all">Collapse all</a>

<pre>
func <b id="fname"><a href="#" class="none" onclick="toggleDiv('aoread');" title="click to show">aoread</a></b>()
<div class="cloak" id="aoread">{
	Reads out parfile and check wfs pixel size
}</div>
func <b id="fname"><a href="#" class="none" onclick="toggleDiv('aoinit');" title="click to show">aoinit</a></b>(disp=,forcemat=)
<div class="cloak" id="aoinit">{
	Parameter checks. Sets some defaults, check logic
	Set array geometry

	<b>Initialize WFS, per sensor:</b>
	<i>if curvature WFS {</i>
		<b id="fname">make_curv_wfs_subs</b>,n,size,sim.pupildiam
		<b id="fname">curv_wfs</b>,pupil,pupil*0.0f,,n,init=1
	<i>} else if Shack-Hartmann WFS {</i>
		<b id="fname">sh_wfs</b>,ipupil,ipupil*0.0f,n,init=1
	<i>}</i>

	<b>Initialize phase screens:</b>
	<b id="fname"><a href="#" class="none" onclick="toggleDiv('get_turb_phase_init');" title="click to show">get_turb_phase_init</a></b>()
<div class="cloak" id="get_turb_phase_init">
		func <b id="fname">get_turb_phase_init</b>(void) {
		Define a number of extern variables
		Compute phase screens normalization factor = f(r0)

		Read the phase screens from disk

		Extend the phase screen length for safe wrapping
		Apply normalization factor to each phase screens

		Build the position vector vs iteration by phase screen

		Pre-compute the XY intersect positions for each WFS GS 
		  as a function(altitude, GS position), for each phase 
		  screens and each DMs.

		Pre-compute the XY intersect positions for each target
		  as a function(altitude, target position), for each phase 
		  screens and each DMs.

		Modify xposvec and yposvec to make sure no indices 
		  stay within the phase screen arrays.
		}		
</div>

	<b>Initialize DM influence functions, per DM:</b>
	<i>if Influence Function file exist {</i>
		read it
	<i>} else {</i>
		compute influence functions
		if bimorph    <b id="fname">make_curvature_dm</b>()
		if stackarray <b id="fname">make_pzt_dm</b>()
		if zernike    <b id="fname">make_zernike_dm</b>()
		if tiptilt    <b id="fname">make_tiptilt_dm</b>()
		write on disk
	<i>}</i>

	<b>Do interaction matrix with all actuators</b>
	<i>if iMat file not on disk or force flag set {</i>
		<b id="fname"><a href="#" class="none" onclick="toggleDiv('do_imat');" title="click to show">do_imat</a></b>()
<div class="cloak" id="do_imat">
			func <b id="fname">do_imat</b>(disp=) {
			<b>Get reference vector:</b>
			refmes = <b id="fname">mult_wfs_int_mat</b>()

			<b>Get WFSs response for each DM and each actuators:</b>
			fill mircube()
			iMat(...) = <b id="fname">mult_wfs_int_mat</b>()-refmes

			Display iMat if requested
			}

</div>		select valid actuators by their response:
		re-write on disk influence function file
		filter iMat
	<i>}</i>

	<b>Set modal gains</b>
	<i>if modal gain file exists {</i>
		read it
	<i>} else {</i>
		create modal gain vector == 1
	<i>}</i>

	<b>Command matrix</b>
	<i>if iMat file on disk and force flag not set {</i>
		read iMat and cMat from disk
	<i>} else {</i>
		<b id="fname"><a href="#" class="none" onclick="toggleDiv('prep_svd');" title="click to show">prep_svd</a></b>()
<div class="cloak" id="prep_svd">
			func <b id="fname">prep_svd</b>(disp=) {
			<b>Decompose to prepare inversion:</b>
			eigenvalues = <b id="fname">SVdec</b>(iMat,u,vt);

			<b>Store u and vt for future use in build_cmat</b>

			Some debug display if requested
			}

</div>		<b id="fname"><a href="#" class="none" onclick="toggleDiv('build_cmat');" title="click to show">build_cmat</a></b>,all=1;
<div class="cloak" id="build_cmat">
			func <b id="fname">build_cmat</b>(all=,nomodalgain=,disp=) {
			<b>Compute matrix of 1/eigenvalues</b>

			<b>Multiply by modal gain if option is set</b>

			The last eigenvalue is filtered except if the 
			  keyword "all" is set

			<b>Compute the Command matrix from the stored u, vt and
			  the just-computed 1/eigenvalue matrix</b>

			Display some stuff if requested
			}

</div>		write iMat and cMat on disk
	<i>}</i>
  
	create aosimul.res if none on disk 

	plot system configuration graphic
}</div>
</pre>
</div>
Page updated on UT $Date: 2010-04-15 02:33:35 $
<p>
 <a href="http://jigsaw.w3.org/css-validator/">
  <img style="border:0;width:88px;height:31px"
       src="http://jigsaw.w3.org/css-validator/images/vcss" 
       alt="Valid CSS!">
 </a>
</p>
</body>
</html>
